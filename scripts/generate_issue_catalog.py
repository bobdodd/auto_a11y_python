#!/usr/bin/env python3
"""
Generate issue_descriptions_enhanced.py from ISSUE_CATALOG_TEMPLATE.md
"""

import re
from pathlib import Path


def parse_template():
    """Parse the template file and extract issue descriptions"""
    template_path = Path(__file__).parent.parent / 'ISSUE_CATALOG_BY_TOUCHPOINT.md'
    
    with open(template_path, 'r', encoding='utf-8') as f:
        content = f.read()
    
    # Pattern to match issue blocks (updated for new format without code blocks)
    pattern = r'^ID:\s*([^\n]+)\nType:\s*([^\n]+)\nImpact:\s*([^\n]+)\nWCAG:\s*([^\n]+)\nDescription:\s*([^\n]+)\nWhy it matters:\s*([^\n]+)\nWho it affects:\s*([^\n]+)\nHow to fix:\s*([^\n]+)'
    
    issues = {}
    for match in re.finditer(pattern, content, re.MULTILINE):
        issue_id = match.group(1).strip()
        issue_type = match.group(2).strip()
        impact = match.group(3).strip()
        wcag = match.group(4).strip()
        description = match.group(5).strip()
        why_matters = match.group(6).strip()
        who_affects = match.group(7).strip()
        how_to_fix = match.group(8).strip()
        
        # Determine category from context (touchpoint header)
        category = 'General'  # Default category
        
        # Skip the template example
        if issue_id == '[Issue identifier from code]':
            continue
        
        # Parse WCAG into a list - extract just the criterion numbers
        wcag_list = []
        if wcag and wcag != 'N/A':
            # Extract pattern like "1.1.1" from "1.1.1 Non-text Content (Level A)"
            import re as regex
            wcag_nums = regex.findall(r'\d+\.\d+\.\d+', wcag)
            wcag_list = wcag_nums
        
        issues[issue_id] = {
            'type': issue_type,
            'impact': impact,
            'wcag': wcag_list,
            'category': category,
            'title': description.split('.')[0] if '.' in description else description,
            'what': description,
            'why': why_matters,
            'who': who_affects,
            'remediation': how_to_fix
        }
    
    return issues


def generate_python_module(issues):
    """Generate the Python module with enhanced descriptions"""
    
    output = '''"""
Auto-generated issue descriptions from ISSUE_CATALOG_BY_TOUCHPOINT.md
DO NOT EDIT THIS FILE DIRECTLY - Edit ISSUE_CATALOG_BY_TOUCHPOINT.md and regenerate
"""

from enum import Enum
from typing import Dict, Any, List


class ImpactScale(Enum):
    """Impact scale for accessibility issues"""
    HIGH = "High"
    MEDIUM = "Medium"  
    LOW = "Low"
    INFO = "Info"


def get_detailed_issue_description(issue_code: str, metadata: Dict[str, Any] = None) -> Dict[str, Any]:
    """
    Get detailed description for an issue code with contextual metadata
    
    Args:
        issue_code: The issue code (e.g., 'headings_ErrEmptyHeading')
        metadata: Additional context about the specific issue instance
        
    Returns:
        Dictionary with detailed description fields
    """
    
    if metadata is None:
        metadata = {}
    
    # Extract the error type from the issue code
    # Handle AI_ prefixed codes specially
    if issue_code.startswith('AI_'):
        error_type = issue_code  # Use full code for AI issues
        category = 'AI'
    elif '_' in issue_code:
        category, error_type = issue_code.split('_', 1)
    else:
        category = 'unknown'
        error_type = issue_code
    
    # Generated descriptions from template
    descriptions = {
'''
    
    # Add each issue description
    for issue_id, details in issues.items():
        # Determine impact enum
        impact_map = {
            'High': 'ImpactScale.HIGH',
            'Medium': 'ImpactScale.MEDIUM',
            'Low': 'ImpactScale.LOW',
            'N/A': 'ImpactScale.INFO',
            'Info': 'ImpactScale.INFO'
        }
        impact_enum = impact_map.get(details['impact'], 'ImpactScale.MEDIUM')
        
        # Format WCAG list
        wcag_str = str(details['wcag'])
        
        # Escape quotes in strings
        title = details['title'].replace('"', '\\"').replace("'", "\\'")
        what = details['what'].replace('"', '\\"').replace("'", "\\'")
        why = details['why'].replace('"', '\\"').replace("'", "\\'")
        who = details['who'].replace('"', '\\"').replace("'", "\\'")
        remediation = details['remediation'].replace('"', '\\"').replace("'", "\\'")
        
        output += f'''        '{issue_id}': {{
            'title': "{title}",
            'what': "{what}",
            'why': "{why}",
            'who': "{who}",
            'impact': {impact_enum}.value,
            'wcag': {wcag_str},
            'remediation': "{remediation}"
        }},
'''
    
    output += '''    }
    
    # Get the specific description for this error type
    if error_type in descriptions:
        desc = descriptions[error_type].copy()
        
        # Replace metadata placeholders in the description
        for key in ['title', 'what', 'why', 'who', 'remediation']:
            if key in desc and isinstance(desc[key], str):
                # Replace {found} with actual font name for font issues
                if '{found}' in desc[key] and 'found' in metadata:
                    desc[key] = desc[key].replace('{found}', str(metadata.get('found', 'unknown')))
                # Replace other metadata placeholders
                for meta_key, meta_value in metadata.items():
                    placeholder = '{' + meta_key + '}'
                    if placeholder in desc[key]:
                        desc[key] = desc[key].replace(placeholder, str(meta_value))
        
        return desc
    
    # Default fallback
    return {
        'title': f"Accessibility issue: {error_type}",
        'what': f"An accessibility issue of type '{error_type}' was detected.",
        'why': "This issue may create barriers for users with disabilities.",
        'who': "Users with disabilities",
        'impact': ImpactScale.MEDIUM.value,
        'wcag': [],
        'remediation': "Review the specific issue and apply appropriate accessibility fixes."
    }


def format_issue_for_display(issue_code: str, violation_data: Dict[str, Any]) -> Dict[str, str]:
    """
    Format an issue with all its metadata for display
    """
    # Get the detailed description using the metadata
    description = get_detailed_issue_description(issue_code, violation_data)
    
    # Add any additional runtime data
    description['issue_id'] = issue_code
    description['location'] = violation_data.get('xpath', 'Not specified')
    description['element'] = violation_data.get('element', 'Not specified')
    description['url'] = violation_data.get('url', 'Not specified')
    
    return description
'''
    
    return output


def main():
    """Main function to generate the module"""
    print("Parsing ISSUE_CATALOG_BY_TOUCHPOINT.md...")
    issues = parse_template()
    print(f"Found {len(issues)} issue descriptions")
    
    print("Generating Python module...")
    module_content = generate_python_module(issues)
    
    output_path = Path(__file__).parent.parent / 'auto_a11y' / 'reporting' / 'issue_descriptions_enhanced.py'
    
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(module_content)
    
    print(f"Successfully generated {output_path}")
    print(f"Total issues: {len(issues)}")
    
    # Show breakdown by type
    types = {}
    for issue_id, details in issues.items():
        t = details['type']
        types[t] = types.get(t, 0) + 1
    
    print("\nBreakdown by type:")
    for t, count in sorted(types.items()):
        print(f"  {t}: {count}")


if __name__ == '__main__':
    main()