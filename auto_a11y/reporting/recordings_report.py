"""
Recordings report generator for AutoA11y

Generates reports from manual accessibility audit recordings and lived experience testing.
"""

import logging
import json
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional
from collections import defaultdict
from jinja2 import Environment, FileSystemLoader, select_autoescape

logger = logging.getLogger(__name__)


class RecordingsReportGenerator:
    """Generate reports from accessibility recordings"""

    def __init__(self, db, config: dict):
        """
        Initialize report generator

        Args:
            db: Database connection
            config: Configuration dictionary
        """
        self.db = db
        self.config = config
        self.reports_dir = Path(config.get('REPORTS_DIR', 'reports'))
        self.reports_dir.mkdir(exist_ok=True)

    def _read_embedded_assets(self) -> dict:
        """Read Bootstrap CSS and JS files for embedding inline in standalone reports"""
        import re
        static_dir = Path(__file__).parent.parent / 'web' / 'static'

        assets = {}
        try:
            # Read Bootstrap CSS
            bootstrap_css_path = static_dir / 'css' / 'bootstrap.min.css'
            bootstrap_css = bootstrap_css_path.read_text(encoding='utf-8')
            # Remove source map reference to prevent browser from trying to load it
            bootstrap_css = bootstrap_css.replace('/*# sourceMappingURL=bootstrap.min.css.map */', '')
            assets['bootstrap_css'] = bootstrap_css

            # Read Bootstrap Icons CSS
            bootstrap_icons_path = static_dir / 'css' / 'bootstrap-icons.css'
            bootstrap_icons_css = bootstrap_icons_path.read_text(encoding='utf-8')
            # Replace font file URLs with empty string to prevent 404 errors
            bootstrap_icons_css = re.sub(
                r'src:\s*url\([^)]+\)(\s*format\([^)]+\))?(,\s*url\([^)]+\)(\s*format\([^)]+\))?)*;',
                'src: url("");',
                bootstrap_icons_css
            )
            assets['bootstrap_icons_css'] = bootstrap_icons_css

            # Read Bootstrap JS
            bootstrap_js_path = static_dir / 'js' / 'bootstrap.bundle.min.js'
            bootstrap_js = bootstrap_js_path.read_text(encoding='utf-8')
            # Remove source map reference to prevent browser from trying to load it
            bootstrap_js = bootstrap_js.replace('//# sourceMappingURL=bootstrap.bundle.min.js.map', '')
            assets['bootstrap_js'] = bootstrap_js

        except Exception as e:
            logger.error(f"Failed to read embedded assets: {e}")
            # Return empty strings if files can't be read
            assets = {
                'bootstrap_css': '',
                'bootstrap_icons_css': '',
                'bootstrap_js': ''
            }

        return assets

    def _get_translations(self) -> Dict[str, Dict[str, str]]:
        """Get translations for EN and FR languages for recordings reports"""
        translations = {
            'en': {
                'recordings_report': 'Recordings Report',
                'auto_a11y_report': 'Auto A11y Report',
                'generated': 'Generated',
                'project': 'Project',
                'wcag_level': 'WCAG Level',
                'generated_by': 'Generated by',
                'executive_summary': 'Executive Summary',
                'total_recordings': 'Total Recordings',
                'total_issues': 'Total Issues',
                'high': 'High',
                'medium': 'Medium',
                'low': 'Low',
                'recordings': 'Recordings',
                'auditor': 'Auditor',
                'role': 'Role',
                'key_takeaways': 'Key Takeaways',
                'user_painpoints': 'User Painpoints',
                'user_assertions': 'User Assertions',
                'accessibility_issues': 'Accessibility Issues',
                'touchpoint': 'Touchpoint',
                'timecodes': 'Timecodes',
                'wcag_criteria': 'WCAG Criteria',
                'recording': 'Recording',
                'issues_by_touchpoint': 'Issues by Touchpoint',
                'index': 'Index',
                # Issue enhanced descriptions
                'what': 'What',
                'why': 'Why',
                'who_affected': 'Who is affected',
                'how_to_fix': 'How to fix',
                # Touchpoints
                'Color Contrast': 'Color Contrast',
                'Forms': 'Forms',
                'General': 'General',
                'Images': 'Images',
                'Navigation': 'Navigation',
                'Page Structure': 'Page Structure',
                'Typography': 'Typography',
            },
            'fr': {
                'recordings_report': 'Rapport d\'enregistrements',
                'auto_a11y_report': 'Rapport Auto A11y',
                'generated': 'Généré',
                'project': 'Projet',
                'wcag_level': 'Niveau WCAG',
                'generated_by': 'Généré par',
                'executive_summary': 'Résumé exécutif',
                'total_recordings': 'Total des enregistrements',
                'total_issues': 'Total des problèmes',
                'high': 'Élevé',
                'medium': 'Moyen',
                'low': 'Faible',
                'recordings': 'Enregistrements',
                'auditor': 'Auditeur',
                'role': 'Rôle',
                'key_takeaways': 'Points clés à retenir',
                'user_painpoints': 'Points de douleur de l\'utilisateur',
                'user_assertions': 'Déclarations de l\'utilisateur',
                'accessibility_issues': 'Problèmes d\'accessibilité trouvés',
                'touchpoint': 'Point de contact',
                'timecodes': 'Codes temporels',
                'wcag_criteria': 'Critères WCAG',
                'recording': 'Enregistrement',
                'issues_by_touchpoint': 'Problèmes par point de contact',
                'index': 'Index',
                # Issue enhanced descriptions
                'what': 'Quoi',
                'why': 'Pourquoi',
                'who_affected': 'Qui est affecté',
                'how_to_fix': 'Comment corriger',
                # Touchpoints (translated)
                'Color Contrast': 'Contraste des couleurs',
                'Forms': 'Formulaires',
                'General': 'Général',
                'Images': 'Images',
                'Navigation': 'Navigation',
                'Page Structure': 'Structure de la page',
                'Typography': 'Typographie',
            }
        }
        return translations

    def generate_project_recordings_report(
        self,
        project_id: str,
        format: str = 'html',
        include_summary: bool = True,
        include_timecodes: bool = True,
        include_wcag: bool = True,
        group_by_touchpoint: bool = True,
        language: str = 'en'
    ) -> str:
        """
        Generate a report for all recordings in a project

        Args:
            project_id: Project ID
            format: Output format (html, pdf, xlsx)
            include_summary: Include executive summary
            include_timecodes: Include timecodes for issues
            include_wcag: Include WCAG criteria mappings
            group_by_touchpoint: Group issues by touchpoint
            language: Language for report content ('en' or 'fr', default: 'en')

        Returns:
            Path to generated report file
        """
        # Get project
        project = self.db.get_project(project_id)
        if not project:
            raise ValueError(f"Project not found: {project_id}")

        # Get all recordings for this project
        recordings = self.db.get_recordings(project_id=project_id)
        if not recordings:
            raise ValueError(f"No recordings found for project: {project.name}")

        # Collect all issues from recordings
        # For bilingual reports, we'll get ALL issues but separate them by language
        all_issues_en = []
        all_issues_fr = []
        issues_by_recording_en = {}
        issues_by_recording_fr = {}

        for recording in recordings:
            all_issues = self.db.get_recording_issues_for_recording(recording.recording_id)

            # Separate issues by language
            issues_en = [i for i in all_issues if i.language == 'en']
            issues_fr = [i for i in all_issues if i.language == 'fr']

            issues_by_recording_en[recording.recording_id] = issues_en
            issues_by_recording_fr[recording.recording_id] = issues_fr
            all_issues_en.extend(issues_en)
            all_issues_fr.extend(issues_fr)

        # For standalone bilingual reports, we need both language versions
        # The template will use data-lang attributes to show/hide based on language selection
        all_issues = all_issues_en  # Primary language for stats
        issues_by_recording = issues_by_recording_en  # Primary for initial display

        # Calculate summary statistics
        stats = self._calculate_statistics(recordings, all_issues)

        # Group issues if requested
        issues_by_touchpoint = None
        if group_by_touchpoint:
            issues_by_touchpoint = self._group_by_touchpoint(all_issues)

        # Generate report based on format
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        project_name_safe = project.name.replace(' ', '_').replace('/', '_')

        if format == 'html':
            filename = f"{project_name_safe}_recordings_{timestamp}.html"
            report_path = self.reports_dir / filename
            self._generate_html_report(
                report_path,
                project,
                recordings,
                all_issues,
                issues_by_touchpoint,
                issues_by_recording,
                issues_by_recording_en,
                issues_by_recording_fr,
                stats,
                include_summary,
                include_timecodes,
                include_wcag,
                group_by_touchpoint,
                language
            )
        elif format == 'pdf':
            filename = f"{project_name_safe}_recordings_{timestamp}.pdf"
            report_path = self.reports_dir / filename
            self._generate_pdf_report(
                report_path,
                project,
                recordings,
                all_issues,
                issues_by_touchpoint,
                stats,
                include_summary,
                include_timecodes,
                include_wcag
            )
        elif format == 'xlsx':
            filename = f"{project_name_safe}_recordings_{timestamp}.xlsx"
            report_path = self.reports_dir / filename
            self._generate_xlsx_report(
                report_path,
                project,
                recordings,
                all_issues,
                issues_by_touchpoint,
                stats,
                include_timecodes,
                include_wcag
            )
        else:
            raise ValueError(f"Unsupported format: {format}")

        logger.info(f"Generated recordings report: {report_path}")
        return str(report_path)

    def _calculate_statistics(self, recordings, issues):
        """Calculate summary statistics"""
        total_recordings = len(recordings)
        total_issues = len(issues)

        # Count by impact
        high_count = sum(1 for issue in issues if issue.impact.value.lower() in ['high', 'critical'])
        medium_count = sum(1 for issue in issues if issue.impact.value.lower() in ['medium', 'moderate'])
        low_count = sum(1 for issue in issues if issue.impact.value.lower() == 'low')

        # Count by recording type
        audit_recordings = sum(1 for r in recordings if r.recording_type.value == 'audit')
        lived_exp_recordings = len(recordings) - audit_recordings

        # Count touchpoints
        touchpoints = set(issue.touchpoint for issue in issues if issue.touchpoint)

        return {
            'total_recordings': total_recordings,
            'total_issues': total_issues,
            'high_count': high_count,
            'medium_count': medium_count,
            'low_count': low_count,
            'audit_recordings': audit_recordings,
            'lived_experience_recordings': lived_exp_recordings,
            'unique_touchpoints': len(touchpoints),
            'touchpoints': sorted(touchpoints) if touchpoints else []
        }

    def _group_by_touchpoint(self, issues):
        """Group issues by touchpoint"""
        grouped = defaultdict(list)
        for issue in issues:
            touchpoint = issue.touchpoint or "General"
            grouped[touchpoint].append(issue)
        return dict(sorted(grouped.items()))

    def _generate_html_report(
        self,
        output_path,
        project,
        recordings,
        issues,
        issues_by_touchpoint,
        issues_by_recording,
        issues_by_recording_en,
        issues_by_recording_fr,
        stats,
        include_summary,
        include_timecodes,
        include_wcag,
        group_by_touchpoint,
        language='en'
    ):
        """Generate HTML report using Jinja2 template with bilingual support"""
        # Get translations
        all_translations = self._get_translations()
        translations_en = all_translations['en']
        translations_fr = all_translations['fr']
        t = all_translations[language]  # Current language translations

        # Read embedded assets for standalone HTML
        embedded_assets = self._read_embedded_assets()

        # Setup Jinja2 environment
        templates_dir = Path(__file__).parent.parent / 'web' / 'templates'
        env = Environment(
            loader=FileSystemLoader(str(templates_dir)),
            autoescape=select_autoescape(['html', 'xml'])
        )

        # Load the standalone template (fully self-contained with embedded assets)
        template = env.get_template('static_report/recordings_report_standalone.html')

        # Prepare template context with both language versions for bilingual support
        context = {
            'project': project,
            'recordings': recordings,
            'issues': issues,
            'issues_by_touchpoint': issues_by_touchpoint if group_by_touchpoint else None,
            'issues_by_recording': issues_by_recording,
            'issues_by_recording_en': issues_by_recording_en,  # English issues
            'issues_by_recording_fr': issues_by_recording_fr,  # French issues
            'stats': stats,
            'include_summary': include_summary,
            'include_timecodes': include_timecodes,
            'include_wcag': include_wcag,
            'group_by_touchpoint': group_by_touchpoint,
            'language': language,
            't': t,
            'translations_en': translations_en,
            'translations_fr': translations_fr,
            'translations_json': json.dumps({'en': translations_en, 'fr': translations_fr}),
            'report_date': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'asset_path': '',  # Empty for standalone - assets are embedded
            'bootstrap_css': embedded_assets['bootstrap_css'],
            'bootstrap_icons_css': embedded_assets['bootstrap_icons_css'],
            'bootstrap_js': embedded_assets['bootstrap_js']
        }

        # Render the template
        html_content = template.render(**context)

        # Write to file
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(html_content)

        logger.info(f"Generated HTML recordings report: {output_path}")

    def _generate_pdf_report(self, output_path, project, recordings, issues, issues_by_touchpoint, stats, include_summary, include_timecodes, include_wcag):
        """Generate PDF report (placeholder - would use library like ReportLab or WeasyPrint)"""
        # For now, generate HTML and note that PDF conversion would be done here
        html_path = str(output_path).replace('.pdf', '.html')
        self._generate_html_report(
            html_path,
            project,
            recordings,
            issues,
            issues_by_touchpoint,
            stats,
            include_summary,
            include_timecodes,
            include_wcag
        )
        # TODO: Convert HTML to PDF using WeasyPrint or similar
        logger.warning("PDF generation not fully implemented - HTML report generated instead")
        import shutil
        shutil.copy(html_path, output_path.replace('.pdf', '_temp.html'))

    def _generate_xlsx_report(self, output_path, project, recordings, issues, issues_by_touchpoint, stats, include_timecodes, include_wcag):
        """Generate Excel report (placeholder - would use library like openpyxl)"""
        try:
            import openpyxl
            from openpyxl.styles import Font, PatternFill, Alignment

            wb = openpyxl.Workbook()

            # Summary sheet
            ws_summary = wb.active
            ws_summary.title = "Summary"
            ws_summary['A1'] = "Recordings Report"
            ws_summary['A1'].font = Font(size=16, bold=True)
            ws_summary['A3'] = "Project:"
            ws_summary['B3'] = project.name
            ws_summary['A4'] = "Generated:"
            ws_summary['B4'] = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

            ws_summary['A6'] = "Total Recordings:"
            ws_summary['B6'] = stats['total_recordings']
            ws_summary['A7'] = "Total Issues:"
            ws_summary['B7'] = stats['total_issues']
            ws_summary['A8'] = "High Impact:"
            ws_summary['B8'] = stats['high_count']
            ws_summary['A9'] = "Medium Impact:"
            ws_summary['B9'] = stats['medium_count']
            ws_summary['A10'] = "Low Impact:"
            ws_summary['B10'] = stats['low_count']

            # Issues sheet
            ws_issues = wb.create_sheet("Issues")
            headers = ['Title', 'Impact', 'Touchpoint', 'What', 'Why', 'Who', 'Remediation']
            if include_wcag:
                headers.append('WCAG')
            if include_timecodes:
                headers.append('Timecodes')

            for col, header in enumerate(headers, 1):
                cell = ws_issues.cell(1, col, header)
                cell.font = Font(bold=True)
                cell.fill = PatternFill(start_color="366092", end_color="366092", fill_type="solid")
                cell.font = Font(color="FFFFFF", bold=True)

            for row, issue in enumerate(issues, 2):
                ws_issues.cell(row, 1, issue.title)
                ws_issues.cell(row, 2, issue.impact.value.upper())
                ws_issues.cell(row, 3, issue.touchpoint or "General")
                ws_issues.cell(row, 4, issue.what or "")
                ws_issues.cell(row, 5, issue.why or "")
                ws_issues.cell(row, 6, issue.who or "")
                ws_issues.cell(row, 7, issue.remediation or "")

                col = 8
                if include_wcag:
                    wcag_str = ", ".join([f"{w.criteria} (Level {w.level})" for w in issue.wcag]) if issue.wcag else ""
                    ws_issues.cell(row, col, wcag_str)
                    col += 1

                if include_timecodes:
                    tc_str = ", ".join([f"{tc.start}-{tc.end}" for tc in issue.timecodes]) if issue.timecodes else ""
                    ws_issues.cell(row, col, tc_str)

            # Recordings sheet
            ws_recordings = wb.create_sheet("Recordings")
            rec_headers = ['ID', 'Title', 'Type', 'Auditor/Tester', 'Date', 'Total Issues', 'High', 'Medium', 'Low']
            for col, header in enumerate(rec_headers, 1):
                cell = ws_recordings.cell(1, col, header)
                cell.font = Font(bold=True)
                cell.fill = PatternFill(start_color="366092", end_color="366092", fill_type="solid")
                cell.font = Font(color="FFFFFF", bold=True)

            for row, recording in enumerate(recordings, 2):
                ws_recordings.cell(row, 1, recording.recording_id)
                ws_recordings.cell(row, 2, recording.title)
                ws_recordings.cell(row, 3, recording.recording_type.value.replace('_', ' ').title())
                ws_recordings.cell(row, 4, recording.auditor_name or "N/A")
                ws_recordings.cell(row, 5, recording.recorded_date.strftime('%Y-%m-%d') if recording.recorded_date else "N/A")
                ws_recordings.cell(row, 6, recording.total_issues)
                ws_recordings.cell(row, 7, recording.high_impact_count)
                ws_recordings.cell(row, 8, recording.medium_impact_count)
                ws_recordings.cell(row, 9, recording.low_impact_count)

            wb.save(output_path)

        except ImportError:
            logger.error("openpyxl not installed - cannot generate Excel report")
            raise
