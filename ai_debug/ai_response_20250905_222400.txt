============================================================
PROMPT:
============================================================
Analyze the reading order of this web page.

        Compare the natural visual reading order (left-to-right, top-to-bottom in English)
        with the DOM order in the HTML.
        
        Look for:
        1. Content that appears visually before other content but comes after in DOM
        2. Multi-column layouts where DOM order doesn't match visual flow
        3. Floating or absolutely positioned elements that disrupt reading order
        4. Content that visually appears related but is separated in DOM
        
        Return ONLY valid JSON:
        {
            "reading_order_matches": true/false,
            "issues": [
                {
                    "description": "Description of mismatch",
                    "visual_order": "What users see first",
                    "dom_order": "What screen readers read first",
                    "impact": "How this affects users"
                }
            ],
            "uses_layout_table": true/false,
            "has_multi_column": true/false,
            "recommendation": "How to fix reading order"
        }
            
            HTML Content:
            <html lang="en"><head>
  <title></title>
  <link href="https://fonts.googleapis.com/css?family=Lobster" rel="stylesheet">
  <style>
    * {
      font-family: "Lobster";
    }

    body {
      background-color: #000;
      color: #fff;
      margin: 0;
      padding: 0;
    }

    .skip-link {
      position: absolute;
      top: -40px;
      left: 0;
      background-color: transparent;
      color: #fff;
      padding: 8px;
      z-index: 100;
      transition: top 0.3s;
    }

    .skip-link:focus {
      top: 0;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px;
      background-color: #333;
    }

    .logo img {
      width: 100px;
      height: auto;
    }

    .menu-toggle {
      display: none;
      cursor: pointer;
    }

    .menu {
      display: flex;
      list-style: none;
      margin: 0;
      padding: 0;
    }

    .menu li {
      margin-left: 20px;
    }

    .menu a {
      color: #fff;
      text-decoration: none;
      font-size: 18px;
    }

    h1 {
      font-size: 48px;
      text-align: center;
      animation: colorChange 6s infinite;
      text-transform: uppercase;
      font-style: italic;
    }

    p {
      font-size: 18px;
      line-height: 1.5;
      text-align: justify;
      padding: 20px;
      background-image: url('https://example.com/busy-background.gif');
      background-size: cover;
      margin-left: 100px;
      margin-right: 100px;
    }

    a {
      color: #ff0;
      text-decoration: none;
      font-size: 24px;
      display: block;
      margin-top: 20px;
      /* animation: blink 1s infinite; */
    }



    .language-switcher a {
      display: inline-block;
      margin-left: 10px;
      font-size: 16px;
      color: #fff;
      text-decoration: none;
      pointer-events: none;
    }

    @media screen and (max-width: 768px) {
      .menu {
        display: none;
      }

      .menu-toggle {
        display: block;
      }

      .menu.active {
        display: flex;
        flex-direction: column;
        position: absolute;
        top: 80px;
        left: 0;
        width: 100%;
        background-color: #333;
        padding: 20px;
      }

      .menu.active li {
        margin: 10px 0;
      }
    }

    @keyframes colorChange {
      0% {
        color: #f00;
      }

      25% {
        color: #0f0;
      }

      50% {
        color: #00f;
      }

      75% {
        color: #f0f;
      }

      100% {
        color: #f00;
      }
    }

    @keyframes blink {
      0% {
        opacity: 1;
      }

      50% {
        opacity: 0;
      }

      100% {
        opacity: 1;
      }
    }

    .cookie-notice {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background-color: #f2f2f2;
      padding: 10px;
      text-align: center;
      font-size: 10px;
    }

    .cookie-notice p {
      margin: 0;
      display: inline-block;
      vertical-align: middle;
      font-size: 10px;

      color: #777;
    }

    .cookie-notice a {
      color: #007bff;
      text-decoration: none;
    }

    .cookie-notice button {
      background-color: #007bff;
      color: #fff;
      border: none;
      padding: 8px 16px;
      margin-left: 10px;
      cursor: pointer;
      vertical-align: middle;
    }

    #absolutePoistion {
      position: absolute;
      top: 70px;
      left: 30%;
    }

    .modal {
      display: none;
      position: fixed;
      z-index: 1;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0, 0, 0, 0.4);
    }

    .modal-content {
      background-color: #fefefe;
      margin: 15% auto;
      padding: 20px;
      border: 1px solid #888;
      width: 80%;
      max-width: 500px;
      border-radius: 5px;
      box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);
    }

    .close {
      color: #aaa;
      float: right;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
    }

    .close:hover {
      color: black;
      text-decoration: none;
      cursor: pointer;
    }

    .carousel-container {
      width: 600px;
      height: 400px;
      position: relative;
      overflow: hidden;
    }

    .carousel-slide {
      width: 100%;
      height: 100%;
      position: absolute;
      transition: all 0.5s ease;
    }

    .carousel-slide img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    #french {
      visibility: hidden;
    }
    
  </style>

<script type="text/javascript">/////////////////////////////////////////////////////////////
// Calculation of the accessibe name
/////////////////////////////////////////////////////////////

/**
 * Returns a context instance in its default state.
 */
function getDefaultContext() {
    return {
        inherited: {
            visitedNodes: [],
            nodesUsed: new Set(),
            rulesApplied: new Set(),
        },
    };
}

/*
 * Helper functions used by more than 1 rule 
 */

function closest(element, selector) {
    if (element.closest) {
        return element.closest(selector);
    }
}

/**
 * Calculates whether or not a given element is focusable.
 * @param elem - The element whose focusability is to be calculated.
 */
function isFocusable(elem) {
    // See https://html.spec.whatwg.org/multipage/interaction.html#the-tabindex-attribute
    if ((elem instanceof HTMLAnchorElement ||
        elem instanceof HTMLAreaElement ||
        elem instanceof HTMLLinkElement) &&
        elem.hasAttribute('href')) {
        return true;
    }
    if ((elem instanceof HTMLInputElement ||
        elem instanceof HTMLSelectElement ||
        elem instanceof HTMLTextAreaElement ||
        elem instanceof HTMLButtonElement) &&
        !elem.hasAttribute('disabled')) {
        return true;
    }
    return elem.hasAttribute('tabindex') || elem.isContentEditable;
}

/**
 * Looks at a variety of characteristics (CSS, size on screen, attributes)
 * to determine if 'node' should be considered hidden
 * @param node - node whose hidden-ness is being calculated
 * @return - whether or not the node is considered hidden
 */
// #SPEC_ASSUMPTION (A.2) : definition of 'hidden'
function isHidden(node, context) {
    if (!(node instanceof HTMLElement)) {
        return false;
    }
    // #SPEC_ASSUMPTION (A.3) : options shouldn't be hidden
    if (node instanceof HTMLOptionElement &&
        closest(node, 'select') !== null &&
        context.inherited.partOfName) {
        return false;
    }
    const notDisplayed = node.offsetHeight === 0 && node.offsetWidth === 0;
    if (notDisplayed && !isFocusable(node)) {
        return true;
    }
    const visibility = window.getComputedStyle(node).visibility;
    if (visibility === 'hidden') {
        return true;
    }
    const hiddenAncestor = closest(node, '[hidden],[aria-hidden="true"]');
    if (hiddenAncestor !== null) {
        return true;
    }
    return false;
}

/**
 * Condition for applying rule 2A
 * @param node - The node whose text alternative is being calculated
 * @param context - Additional information relevant to the text alternative
 *     computation for node
 * @return - Whether or not node satisfies the condition for rule 2A
 */
function rule2ACondition(node, context) {
    // #SPEC_ASSUMPTION (A.1) : definition of 'directly referenced'
    return isHidden(node, context) && !context.directLabelReference;
}

/**
 * Implementation of rule 2A
 * @param node - The element whose text alternative is being calculated
 * @param context - Additional information relevant to the text alternative
 *     computation for node
 * @return - The text alternative string is returned if condition is true,
 * null is returned otherwise, indicating that the condition of this rule was
 * not satisfied.
 */
function rule2A(node, context = getDefaultContext()) {
    let result = null;
    if (rule2ACondition(node, context)) {
        result = '';
    }
    return result;
}

/**
 * Get any HTMLElement referenced in the aria-labelledby attribute
 * of 'elem' that exist in the document (i.e is 'valid')
 * @param elem - element whose aria-labelledby attribute is considered
 * @return - An array of any HTMLElement in the document that is referenced
 * by elem's aria-labelledby
 */
function resolveValidAriaLabelledbyIdrefs(elem) {
    var _a, _b;
    const idrefs = (_b = (_a = elem.getAttribute('aria-labelledby')) === null || _a === void 0 ? void 0 : _a.split(' ')) !== null && _b !== void 0 ? _b : [];
    const validElems = [];
    for (const id of idrefs) {
        const elem = document.getElementById(id);
        if (elem) {
            validElems.push(elem);
        }
    }
    return validElems;
}

/**
 * Implementation of rule 2B
 * @param node - node whose text alternative is being computed
 * @param context - Additional information relevant to the text alternative
 * computation for node
 * @return - The text alternative string is returned if condition is true,
 * null is returned otherwise, indicating that the condition of this rule was
 * not satisfied.
 */
function rule2B(node, context = getDefaultContext()) {
    if (!(node instanceof HTMLElement)) {
        return null;
    }
    // #SPEC_ASSUMPTION (B.1) : definition of 'part of an aria-labelledby traversal'
    if (context.directLabelReference) {
        return null;
    }
    const labelElems = resolveValidAriaLabelledbyIdrefs(node);
    if (labelElems.length === 0) {
        return null;
    }
    return labelElems
        .map(labelElem => {
            context.inherited.partOfName = true;
            return computeTextAlternative(labelElem, {
                directLabelReference: true,
                inherited: context.inherited,
            }).name;
        })
        .join(' ')
        .trim();
}

// Input types that imply role 'textbox' if list attribute is not present,
// and imply role 'combobox' if list attribute is present.
const TEXT_INPUT_TYP  # Limit HTML to avoid token limits
            
============================================================
RAW RESPONSE:
============================================================
Here is the JSON analysis of the reading order for the provided web page:

{
    "reading_order_matches": false,
    "issues": [
        {
            "description": "Header and menu appear visually first but are after main content in the DOM",
            "visual_order": "1. Header with logo and menu, 2. Main content with heading and text, 3. Language switcher, 4. Cookie notice",
            "dom_order": "1. Main content with heading and text, 2. Header with logo and menu, 3. Language switcher, 4. Cookie notice", 
            "impact": "Screen reader users will hear the main content before the header and menu, which may be confusing"
        },
        {
            "description": "Absolutely positioned element disrupts logical reading order",
            "visual_order": "Element appears in the middle of main content",
            "dom_order": "Element comes after main content in the DOM",
            "impact": "Screen reader users will not hear the absolutely positioned content in the proper context"
        }
    ],
    "uses_layout_table": false,
    "has_multi_column": false,
    "recommendation": "Restructure the HTML to have the header and menu come before the main content. Ensure absolutely positioned elements are placed in a logical order in the DOM that matches the visual presentation. Consider using CSS grid or flexbox for layout instead of absolute positioning."
}

The key issues are that the header appears visually first but comes after the main content in the DOM order, and an absolutely positioned element disrupts the logical reading sequence. Fixing the DOM order and using CSS for visual positioning instead of absolute positioning would improve the reading experience for screen reader users and ensure the page makes sense when linearized.
